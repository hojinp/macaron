// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: meringue.proto
#ifndef GRPC_meringue_2eproto__INCLUDED
#define GRPC_meringue_2eproto__INCLUDED

#include "meringue.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>

namespace meringue {

// The Meringue service definition.
class MeringueService final {
 public:
  static constexpr char const* service_full_name() {
    return "meringue.MeringueService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Define RPC methods like StartServer, CheckStatus, etc.
    virtual ::grpc::Status Initialize(::grpc::ClientContext* context, const ::meringue::InitializeRequest& request, ::meringue::InitializeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::meringue::InitializeResponse>> AsyncInitialize(::grpc::ClientContext* context, const ::meringue::InitializeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::meringue::InitializeResponse>>(AsyncInitializeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::meringue::InitializeResponse>> PrepareAsyncInitialize(::grpc::ClientContext* context, const ::meringue::InitializeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::meringue::InitializeResponse>>(PrepareAsyncInitializeRaw(context, request, cq));
    }
    virtual ::grpc::Status PutSingleMD(::grpc::ClientContext* context, const ::meringue::PutSingleMDRequest& request, ::meringue::PutSingleMDResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::meringue::PutSingleMDResponse>> AsyncPutSingleMD(::grpc::ClientContext* context, const ::meringue::PutSingleMDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::meringue::PutSingleMDResponse>>(AsyncPutSingleMDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::meringue::PutSingleMDResponse>> PrepareAsyncPutSingleMD(::grpc::ClientContext* context, const ::meringue::PutSingleMDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::meringue::PutSingleMDResponse>>(PrepareAsyncPutSingleMDRaw(context, request, cq));
    }
    virtual ::grpc::Status GetSingleMD(::grpc::ClientContext* context, const ::meringue::GetSingleMDRequest& request, ::meringue::GetSingleMDResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::meringue::GetSingleMDResponse>> AsyncGetSingleMD(::grpc::ClientContext* context, const ::meringue::GetSingleMDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::meringue::GetSingleMDResponse>>(AsyncGetSingleMDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::meringue::GetSingleMDResponse>> PrepareAsyncGetSingleMD(::grpc::ClientContext* context, const ::meringue::GetSingleMDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::meringue::GetSingleMDResponse>>(PrepareAsyncGetSingleMDRaw(context, request, cq));
    }
    virtual ::grpc::Status DeleteSingleMD(::grpc::ClientContext* context, const ::meringue::DeleteSingleMDRequest& request, ::meringue::DeleteSingleMDResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::meringue::DeleteSingleMDResponse>> AsyncDeleteSingleMD(::grpc::ClientContext* context, const ::meringue::DeleteSingleMDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::meringue::DeleteSingleMDResponse>>(AsyncDeleteSingleMDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::meringue::DeleteSingleMDResponse>> PrepareAsyncDeleteSingleMD(::grpc::ClientContext* context, const ::meringue::DeleteSingleMDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::meringue::DeleteSingleMDResponse>>(PrepareAsyncDeleteSingleMDRaw(context, request, cq));
    }
    virtual ::grpc::Status UpdateCache(::grpc::ClientContext* context, const ::meringue::UpdateCacheRequest& request, ::meringue::UpdateCacheResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::meringue::UpdateCacheResponse>> AsyncUpdateCache(::grpc::ClientContext* context, const ::meringue::UpdateCacheRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::meringue::UpdateCacheResponse>>(AsyncUpdateCacheRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::meringue::UpdateCacheResponse>> PrepareAsyncUpdateCache(::grpc::ClientContext* context, const ::meringue::UpdateCacheRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::meringue::UpdateCacheResponse>>(PrepareAsyncUpdateCacheRaw(context, request, cq));
    }
    virtual ::grpc::Status UpdateSizeAndEvict(::grpc::ClientContext* context, const ::meringue::EvictionRequest& request, ::meringue::EvictionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::meringue::EvictionResponse>> AsyncUpdateSizeAndEvict(::grpc::ClientContext* context, const ::meringue::EvictionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::meringue::EvictionResponse>>(AsyncUpdateSizeAndEvictRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::meringue::EvictionResponse>> PrepareAsyncUpdateSizeAndEvict(::grpc::ClientContext* context, const ::meringue::EvictionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::meringue::EvictionResponse>>(PrepareAsyncUpdateSizeAndEvictRaw(context, request, cq));
    }
    virtual ::grpc::Status RunGC(::grpc::ClientContext* context, const ::meringue::GCRequest& request, ::meringue::GCResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::meringue::GCResponse>> AsyncRunGC(::grpc::ClientContext* context, const ::meringue::GCRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::meringue::GCResponse>>(AsyncRunGCRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::meringue::GCResponse>> PrepareAsyncRunGC(::grpc::ClientContext* context, const ::meringue::GCRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::meringue::GCResponse>>(PrepareAsyncRunGCRaw(context, request, cq));
    }
    virtual ::grpc::Status SortAndWrite(::grpc::ClientContext* context, const ::meringue::SortAndWriteRequest& request, ::meringue::SortAndWriteResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::meringue::SortAndWriteResponse>> AsyncSortAndWrite(::grpc::ClientContext* context, const ::meringue::SortAndWriteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::meringue::SortAndWriteResponse>>(AsyncSortAndWriteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::meringue::SortAndWriteResponse>> PrepareAsyncSortAndWrite(::grpc::ClientContext* context, const ::meringue::SortAndWriteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::meringue::SortAndWriteResponse>>(PrepareAsyncSortAndWriteRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // Define RPC methods like StartServer, CheckStatus, etc.
      virtual void Initialize(::grpc::ClientContext* context, const ::meringue::InitializeRequest* request, ::meringue::InitializeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Initialize(::grpc::ClientContext* context, const ::meringue::InitializeRequest* request, ::meringue::InitializeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PutSingleMD(::grpc::ClientContext* context, const ::meringue::PutSingleMDRequest* request, ::meringue::PutSingleMDResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PutSingleMD(::grpc::ClientContext* context, const ::meringue::PutSingleMDRequest* request, ::meringue::PutSingleMDResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetSingleMD(::grpc::ClientContext* context, const ::meringue::GetSingleMDRequest* request, ::meringue::GetSingleMDResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetSingleMD(::grpc::ClientContext* context, const ::meringue::GetSingleMDRequest* request, ::meringue::GetSingleMDResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void DeleteSingleMD(::grpc::ClientContext* context, const ::meringue::DeleteSingleMDRequest* request, ::meringue::DeleteSingleMDResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteSingleMD(::grpc::ClientContext* context, const ::meringue::DeleteSingleMDRequest* request, ::meringue::DeleteSingleMDResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void UpdateCache(::grpc::ClientContext* context, const ::meringue::UpdateCacheRequest* request, ::meringue::UpdateCacheResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateCache(::grpc::ClientContext* context, const ::meringue::UpdateCacheRequest* request, ::meringue::UpdateCacheResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void UpdateSizeAndEvict(::grpc::ClientContext* context, const ::meringue::EvictionRequest* request, ::meringue::EvictionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateSizeAndEvict(::grpc::ClientContext* context, const ::meringue::EvictionRequest* request, ::meringue::EvictionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void RunGC(::grpc::ClientContext* context, const ::meringue::GCRequest* request, ::meringue::GCResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RunGC(::grpc::ClientContext* context, const ::meringue::GCRequest* request, ::meringue::GCResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SortAndWrite(::grpc::ClientContext* context, const ::meringue::SortAndWriteRequest* request, ::meringue::SortAndWriteResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SortAndWrite(::grpc::ClientContext* context, const ::meringue::SortAndWriteRequest* request, ::meringue::SortAndWriteResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::meringue::InitializeResponse>* AsyncInitializeRaw(::grpc::ClientContext* context, const ::meringue::InitializeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::meringue::InitializeResponse>* PrepareAsyncInitializeRaw(::grpc::ClientContext* context, const ::meringue::InitializeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::meringue::PutSingleMDResponse>* AsyncPutSingleMDRaw(::grpc::ClientContext* context, const ::meringue::PutSingleMDRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::meringue::PutSingleMDResponse>* PrepareAsyncPutSingleMDRaw(::grpc::ClientContext* context, const ::meringue::PutSingleMDRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::meringue::GetSingleMDResponse>* AsyncGetSingleMDRaw(::grpc::ClientContext* context, const ::meringue::GetSingleMDRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::meringue::GetSingleMDResponse>* PrepareAsyncGetSingleMDRaw(::grpc::ClientContext* context, const ::meringue::GetSingleMDRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::meringue::DeleteSingleMDResponse>* AsyncDeleteSingleMDRaw(::grpc::ClientContext* context, const ::meringue::DeleteSingleMDRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::meringue::DeleteSingleMDResponse>* PrepareAsyncDeleteSingleMDRaw(::grpc::ClientContext* context, const ::meringue::DeleteSingleMDRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::meringue::UpdateCacheResponse>* AsyncUpdateCacheRaw(::grpc::ClientContext* context, const ::meringue::UpdateCacheRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::meringue::UpdateCacheResponse>* PrepareAsyncUpdateCacheRaw(::grpc::ClientContext* context, const ::meringue::UpdateCacheRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::meringue::EvictionResponse>* AsyncUpdateSizeAndEvictRaw(::grpc::ClientContext* context, const ::meringue::EvictionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::meringue::EvictionResponse>* PrepareAsyncUpdateSizeAndEvictRaw(::grpc::ClientContext* context, const ::meringue::EvictionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::meringue::GCResponse>* AsyncRunGCRaw(::grpc::ClientContext* context, const ::meringue::GCRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::meringue::GCResponse>* PrepareAsyncRunGCRaw(::grpc::ClientContext* context, const ::meringue::GCRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::meringue::SortAndWriteResponse>* AsyncSortAndWriteRaw(::grpc::ClientContext* context, const ::meringue::SortAndWriteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::meringue::SortAndWriteResponse>* PrepareAsyncSortAndWriteRaw(::grpc::ClientContext* context, const ::meringue::SortAndWriteRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status Initialize(::grpc::ClientContext* context, const ::meringue::InitializeRequest& request, ::meringue::InitializeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::meringue::InitializeResponse>> AsyncInitialize(::grpc::ClientContext* context, const ::meringue::InitializeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::meringue::InitializeResponse>>(AsyncInitializeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::meringue::InitializeResponse>> PrepareAsyncInitialize(::grpc::ClientContext* context, const ::meringue::InitializeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::meringue::InitializeResponse>>(PrepareAsyncInitializeRaw(context, request, cq));
    }
    ::grpc::Status PutSingleMD(::grpc::ClientContext* context, const ::meringue::PutSingleMDRequest& request, ::meringue::PutSingleMDResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::meringue::PutSingleMDResponse>> AsyncPutSingleMD(::grpc::ClientContext* context, const ::meringue::PutSingleMDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::meringue::PutSingleMDResponse>>(AsyncPutSingleMDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::meringue::PutSingleMDResponse>> PrepareAsyncPutSingleMD(::grpc::ClientContext* context, const ::meringue::PutSingleMDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::meringue::PutSingleMDResponse>>(PrepareAsyncPutSingleMDRaw(context, request, cq));
    }
    ::grpc::Status GetSingleMD(::grpc::ClientContext* context, const ::meringue::GetSingleMDRequest& request, ::meringue::GetSingleMDResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::meringue::GetSingleMDResponse>> AsyncGetSingleMD(::grpc::ClientContext* context, const ::meringue::GetSingleMDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::meringue::GetSingleMDResponse>>(AsyncGetSingleMDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::meringue::GetSingleMDResponse>> PrepareAsyncGetSingleMD(::grpc::ClientContext* context, const ::meringue::GetSingleMDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::meringue::GetSingleMDResponse>>(PrepareAsyncGetSingleMDRaw(context, request, cq));
    }
    ::grpc::Status DeleteSingleMD(::grpc::ClientContext* context, const ::meringue::DeleteSingleMDRequest& request, ::meringue::DeleteSingleMDResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::meringue::DeleteSingleMDResponse>> AsyncDeleteSingleMD(::grpc::ClientContext* context, const ::meringue::DeleteSingleMDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::meringue::DeleteSingleMDResponse>>(AsyncDeleteSingleMDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::meringue::DeleteSingleMDResponse>> PrepareAsyncDeleteSingleMD(::grpc::ClientContext* context, const ::meringue::DeleteSingleMDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::meringue::DeleteSingleMDResponse>>(PrepareAsyncDeleteSingleMDRaw(context, request, cq));
    }
    ::grpc::Status UpdateCache(::grpc::ClientContext* context, const ::meringue::UpdateCacheRequest& request, ::meringue::UpdateCacheResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::meringue::UpdateCacheResponse>> AsyncUpdateCache(::grpc::ClientContext* context, const ::meringue::UpdateCacheRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::meringue::UpdateCacheResponse>>(AsyncUpdateCacheRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::meringue::UpdateCacheResponse>> PrepareAsyncUpdateCache(::grpc::ClientContext* context, const ::meringue::UpdateCacheRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::meringue::UpdateCacheResponse>>(PrepareAsyncUpdateCacheRaw(context, request, cq));
    }
    ::grpc::Status UpdateSizeAndEvict(::grpc::ClientContext* context, const ::meringue::EvictionRequest& request, ::meringue::EvictionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::meringue::EvictionResponse>> AsyncUpdateSizeAndEvict(::grpc::ClientContext* context, const ::meringue::EvictionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::meringue::EvictionResponse>>(AsyncUpdateSizeAndEvictRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::meringue::EvictionResponse>> PrepareAsyncUpdateSizeAndEvict(::grpc::ClientContext* context, const ::meringue::EvictionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::meringue::EvictionResponse>>(PrepareAsyncUpdateSizeAndEvictRaw(context, request, cq));
    }
    ::grpc::Status RunGC(::grpc::ClientContext* context, const ::meringue::GCRequest& request, ::meringue::GCResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::meringue::GCResponse>> AsyncRunGC(::grpc::ClientContext* context, const ::meringue::GCRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::meringue::GCResponse>>(AsyncRunGCRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::meringue::GCResponse>> PrepareAsyncRunGC(::grpc::ClientContext* context, const ::meringue::GCRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::meringue::GCResponse>>(PrepareAsyncRunGCRaw(context, request, cq));
    }
    ::grpc::Status SortAndWrite(::grpc::ClientContext* context, const ::meringue::SortAndWriteRequest& request, ::meringue::SortAndWriteResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::meringue::SortAndWriteResponse>> AsyncSortAndWrite(::grpc::ClientContext* context, const ::meringue::SortAndWriteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::meringue::SortAndWriteResponse>>(AsyncSortAndWriteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::meringue::SortAndWriteResponse>> PrepareAsyncSortAndWrite(::grpc::ClientContext* context, const ::meringue::SortAndWriteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::meringue::SortAndWriteResponse>>(PrepareAsyncSortAndWriteRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void Initialize(::grpc::ClientContext* context, const ::meringue::InitializeRequest* request, ::meringue::InitializeResponse* response, std::function<void(::grpc::Status)>) override;
      void Initialize(::grpc::ClientContext* context, const ::meringue::InitializeRequest* request, ::meringue::InitializeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PutSingleMD(::grpc::ClientContext* context, const ::meringue::PutSingleMDRequest* request, ::meringue::PutSingleMDResponse* response, std::function<void(::grpc::Status)>) override;
      void PutSingleMD(::grpc::ClientContext* context, const ::meringue::PutSingleMDRequest* request, ::meringue::PutSingleMDResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetSingleMD(::grpc::ClientContext* context, const ::meringue::GetSingleMDRequest* request, ::meringue::GetSingleMDResponse* response, std::function<void(::grpc::Status)>) override;
      void GetSingleMD(::grpc::ClientContext* context, const ::meringue::GetSingleMDRequest* request, ::meringue::GetSingleMDResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DeleteSingleMD(::grpc::ClientContext* context, const ::meringue::DeleteSingleMDRequest* request, ::meringue::DeleteSingleMDResponse* response, std::function<void(::grpc::Status)>) override;
      void DeleteSingleMD(::grpc::ClientContext* context, const ::meringue::DeleteSingleMDRequest* request, ::meringue::DeleteSingleMDResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void UpdateCache(::grpc::ClientContext* context, const ::meringue::UpdateCacheRequest* request, ::meringue::UpdateCacheResponse* response, std::function<void(::grpc::Status)>) override;
      void UpdateCache(::grpc::ClientContext* context, const ::meringue::UpdateCacheRequest* request, ::meringue::UpdateCacheResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void UpdateSizeAndEvict(::grpc::ClientContext* context, const ::meringue::EvictionRequest* request, ::meringue::EvictionResponse* response, std::function<void(::grpc::Status)>) override;
      void UpdateSizeAndEvict(::grpc::ClientContext* context, const ::meringue::EvictionRequest* request, ::meringue::EvictionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void RunGC(::grpc::ClientContext* context, const ::meringue::GCRequest* request, ::meringue::GCResponse* response, std::function<void(::grpc::Status)>) override;
      void RunGC(::grpc::ClientContext* context, const ::meringue::GCRequest* request, ::meringue::GCResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SortAndWrite(::grpc::ClientContext* context, const ::meringue::SortAndWriteRequest* request, ::meringue::SortAndWriteResponse* response, std::function<void(::grpc::Status)>) override;
      void SortAndWrite(::grpc::ClientContext* context, const ::meringue::SortAndWriteRequest* request, ::meringue::SortAndWriteResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::meringue::InitializeResponse>* AsyncInitializeRaw(::grpc::ClientContext* context, const ::meringue::InitializeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::meringue::InitializeResponse>* PrepareAsyncInitializeRaw(::grpc::ClientContext* context, const ::meringue::InitializeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::meringue::PutSingleMDResponse>* AsyncPutSingleMDRaw(::grpc::ClientContext* context, const ::meringue::PutSingleMDRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::meringue::PutSingleMDResponse>* PrepareAsyncPutSingleMDRaw(::grpc::ClientContext* context, const ::meringue::PutSingleMDRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::meringue::GetSingleMDResponse>* AsyncGetSingleMDRaw(::grpc::ClientContext* context, const ::meringue::GetSingleMDRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::meringue::GetSingleMDResponse>* PrepareAsyncGetSingleMDRaw(::grpc::ClientContext* context, const ::meringue::GetSingleMDRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::meringue::DeleteSingleMDResponse>* AsyncDeleteSingleMDRaw(::grpc::ClientContext* context, const ::meringue::DeleteSingleMDRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::meringue::DeleteSingleMDResponse>* PrepareAsyncDeleteSingleMDRaw(::grpc::ClientContext* context, const ::meringue::DeleteSingleMDRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::meringue::UpdateCacheResponse>* AsyncUpdateCacheRaw(::grpc::ClientContext* context, const ::meringue::UpdateCacheRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::meringue::UpdateCacheResponse>* PrepareAsyncUpdateCacheRaw(::grpc::ClientContext* context, const ::meringue::UpdateCacheRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::meringue::EvictionResponse>* AsyncUpdateSizeAndEvictRaw(::grpc::ClientContext* context, const ::meringue::EvictionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::meringue::EvictionResponse>* PrepareAsyncUpdateSizeAndEvictRaw(::grpc::ClientContext* context, const ::meringue::EvictionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::meringue::GCResponse>* AsyncRunGCRaw(::grpc::ClientContext* context, const ::meringue::GCRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::meringue::GCResponse>* PrepareAsyncRunGCRaw(::grpc::ClientContext* context, const ::meringue::GCRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::meringue::SortAndWriteResponse>* AsyncSortAndWriteRaw(::grpc::ClientContext* context, const ::meringue::SortAndWriteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::meringue::SortAndWriteResponse>* PrepareAsyncSortAndWriteRaw(::grpc::ClientContext* context, const ::meringue::SortAndWriteRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Initialize_;
    const ::grpc::internal::RpcMethod rpcmethod_PutSingleMD_;
    const ::grpc::internal::RpcMethod rpcmethod_GetSingleMD_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteSingleMD_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateCache_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateSizeAndEvict_;
    const ::grpc::internal::RpcMethod rpcmethod_RunGC_;
    const ::grpc::internal::RpcMethod rpcmethod_SortAndWrite_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Define RPC methods like StartServer, CheckStatus, etc.
    virtual ::grpc::Status Initialize(::grpc::ServerContext* context, const ::meringue::InitializeRequest* request, ::meringue::InitializeResponse* response);
    virtual ::grpc::Status PutSingleMD(::grpc::ServerContext* context, const ::meringue::PutSingleMDRequest* request, ::meringue::PutSingleMDResponse* response);
    virtual ::grpc::Status GetSingleMD(::grpc::ServerContext* context, const ::meringue::GetSingleMDRequest* request, ::meringue::GetSingleMDResponse* response);
    virtual ::grpc::Status DeleteSingleMD(::grpc::ServerContext* context, const ::meringue::DeleteSingleMDRequest* request, ::meringue::DeleteSingleMDResponse* response);
    virtual ::grpc::Status UpdateCache(::grpc::ServerContext* context, const ::meringue::UpdateCacheRequest* request, ::meringue::UpdateCacheResponse* response);
    virtual ::grpc::Status UpdateSizeAndEvict(::grpc::ServerContext* context, const ::meringue::EvictionRequest* request, ::meringue::EvictionResponse* response);
    virtual ::grpc::Status RunGC(::grpc::ServerContext* context, const ::meringue::GCRequest* request, ::meringue::GCResponse* response);
    virtual ::grpc::Status SortAndWrite(::grpc::ServerContext* context, const ::meringue::SortAndWriteRequest* request, ::meringue::SortAndWriteResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Initialize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Initialize() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Initialize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Initialize(::grpc::ServerContext* /*context*/, const ::meringue::InitializeRequest* /*request*/, ::meringue::InitializeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestInitialize(::grpc::ServerContext* context, ::meringue::InitializeRequest* request, ::grpc::ServerAsyncResponseWriter< ::meringue::InitializeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PutSingleMD : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PutSingleMD() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_PutSingleMD() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PutSingleMD(::grpc::ServerContext* /*context*/, const ::meringue::PutSingleMDRequest* /*request*/, ::meringue::PutSingleMDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPutSingleMD(::grpc::ServerContext* context, ::meringue::PutSingleMDRequest* request, ::grpc::ServerAsyncResponseWriter< ::meringue::PutSingleMDResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetSingleMD : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetSingleMD() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_GetSingleMD() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSingleMD(::grpc::ServerContext* /*context*/, const ::meringue::GetSingleMDRequest* /*request*/, ::meringue::GetSingleMDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSingleMD(::grpc::ServerContext* context, ::meringue::GetSingleMDRequest* request, ::grpc::ServerAsyncResponseWriter< ::meringue::GetSingleMDResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteSingleMD : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteSingleMD() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_DeleteSingleMD() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteSingleMD(::grpc::ServerContext* /*context*/, const ::meringue::DeleteSingleMDRequest* /*request*/, ::meringue::DeleteSingleMDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteSingleMD(::grpc::ServerContext* context, ::meringue::DeleteSingleMDRequest* request, ::grpc::ServerAsyncResponseWriter< ::meringue::DeleteSingleMDResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateCache : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UpdateCache() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_UpdateCache() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateCache(::grpc::ServerContext* /*context*/, const ::meringue::UpdateCacheRequest* /*request*/, ::meringue::UpdateCacheResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateCache(::grpc::ServerContext* context, ::meringue::UpdateCacheRequest* request, ::grpc::ServerAsyncResponseWriter< ::meringue::UpdateCacheResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateSizeAndEvict : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UpdateSizeAndEvict() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_UpdateSizeAndEvict() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateSizeAndEvict(::grpc::ServerContext* /*context*/, const ::meringue::EvictionRequest* /*request*/, ::meringue::EvictionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateSizeAndEvict(::grpc::ServerContext* context, ::meringue::EvictionRequest* request, ::grpc::ServerAsyncResponseWriter< ::meringue::EvictionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RunGC : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RunGC() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_RunGC() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunGC(::grpc::ServerContext* /*context*/, const ::meringue::GCRequest* /*request*/, ::meringue::GCResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRunGC(::grpc::ServerContext* context, ::meringue::GCRequest* request, ::grpc::ServerAsyncResponseWriter< ::meringue::GCResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SortAndWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SortAndWrite() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_SortAndWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SortAndWrite(::grpc::ServerContext* /*context*/, const ::meringue::SortAndWriteRequest* /*request*/, ::meringue::SortAndWriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSortAndWrite(::grpc::ServerContext* context, ::meringue::SortAndWriteRequest* request, ::grpc::ServerAsyncResponseWriter< ::meringue::SortAndWriteResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Initialize<WithAsyncMethod_PutSingleMD<WithAsyncMethod_GetSingleMD<WithAsyncMethod_DeleteSingleMD<WithAsyncMethod_UpdateCache<WithAsyncMethod_UpdateSizeAndEvict<WithAsyncMethod_RunGC<WithAsyncMethod_SortAndWrite<Service > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_Initialize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Initialize() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::meringue::InitializeRequest, ::meringue::InitializeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::meringue::InitializeRequest* request, ::meringue::InitializeResponse* response) { return this->Initialize(context, request, response); }));}
    void SetMessageAllocatorFor_Initialize(
        ::grpc::MessageAllocator< ::meringue::InitializeRequest, ::meringue::InitializeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::meringue::InitializeRequest, ::meringue::InitializeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Initialize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Initialize(::grpc::ServerContext* /*context*/, const ::meringue::InitializeRequest* /*request*/, ::meringue::InitializeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Initialize(
      ::grpc::CallbackServerContext* /*context*/, const ::meringue::InitializeRequest* /*request*/, ::meringue::InitializeResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PutSingleMD : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PutSingleMD() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::meringue::PutSingleMDRequest, ::meringue::PutSingleMDResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::meringue::PutSingleMDRequest* request, ::meringue::PutSingleMDResponse* response) { return this->PutSingleMD(context, request, response); }));}
    void SetMessageAllocatorFor_PutSingleMD(
        ::grpc::MessageAllocator< ::meringue::PutSingleMDRequest, ::meringue::PutSingleMDResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::meringue::PutSingleMDRequest, ::meringue::PutSingleMDResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PutSingleMD() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PutSingleMD(::grpc::ServerContext* /*context*/, const ::meringue::PutSingleMDRequest* /*request*/, ::meringue::PutSingleMDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PutSingleMD(
      ::grpc::CallbackServerContext* /*context*/, const ::meringue::PutSingleMDRequest* /*request*/, ::meringue::PutSingleMDResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetSingleMD : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetSingleMD() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::meringue::GetSingleMDRequest, ::meringue::GetSingleMDResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::meringue::GetSingleMDRequest* request, ::meringue::GetSingleMDResponse* response) { return this->GetSingleMD(context, request, response); }));}
    void SetMessageAllocatorFor_GetSingleMD(
        ::grpc::MessageAllocator< ::meringue::GetSingleMDRequest, ::meringue::GetSingleMDResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::meringue::GetSingleMDRequest, ::meringue::GetSingleMDResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetSingleMD() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSingleMD(::grpc::ServerContext* /*context*/, const ::meringue::GetSingleMDRequest* /*request*/, ::meringue::GetSingleMDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSingleMD(
      ::grpc::CallbackServerContext* /*context*/, const ::meringue::GetSingleMDRequest* /*request*/, ::meringue::GetSingleMDResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DeleteSingleMD : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DeleteSingleMD() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::meringue::DeleteSingleMDRequest, ::meringue::DeleteSingleMDResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::meringue::DeleteSingleMDRequest* request, ::meringue::DeleteSingleMDResponse* response) { return this->DeleteSingleMD(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteSingleMD(
        ::grpc::MessageAllocator< ::meringue::DeleteSingleMDRequest, ::meringue::DeleteSingleMDResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::meringue::DeleteSingleMDRequest, ::meringue::DeleteSingleMDResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DeleteSingleMD() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteSingleMD(::grpc::ServerContext* /*context*/, const ::meringue::DeleteSingleMDRequest* /*request*/, ::meringue::DeleteSingleMDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DeleteSingleMD(
      ::grpc::CallbackServerContext* /*context*/, const ::meringue::DeleteSingleMDRequest* /*request*/, ::meringue::DeleteSingleMDResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_UpdateCache : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_UpdateCache() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::meringue::UpdateCacheRequest, ::meringue::UpdateCacheResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::meringue::UpdateCacheRequest* request, ::meringue::UpdateCacheResponse* response) { return this->UpdateCache(context, request, response); }));}
    void SetMessageAllocatorFor_UpdateCache(
        ::grpc::MessageAllocator< ::meringue::UpdateCacheRequest, ::meringue::UpdateCacheResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::meringue::UpdateCacheRequest, ::meringue::UpdateCacheResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_UpdateCache() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateCache(::grpc::ServerContext* /*context*/, const ::meringue::UpdateCacheRequest* /*request*/, ::meringue::UpdateCacheResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UpdateCache(
      ::grpc::CallbackServerContext* /*context*/, const ::meringue::UpdateCacheRequest* /*request*/, ::meringue::UpdateCacheResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_UpdateSizeAndEvict : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_UpdateSizeAndEvict() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::meringue::EvictionRequest, ::meringue::EvictionResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::meringue::EvictionRequest* request, ::meringue::EvictionResponse* response) { return this->UpdateSizeAndEvict(context, request, response); }));}
    void SetMessageAllocatorFor_UpdateSizeAndEvict(
        ::grpc::MessageAllocator< ::meringue::EvictionRequest, ::meringue::EvictionResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::meringue::EvictionRequest, ::meringue::EvictionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_UpdateSizeAndEvict() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateSizeAndEvict(::grpc::ServerContext* /*context*/, const ::meringue::EvictionRequest* /*request*/, ::meringue::EvictionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UpdateSizeAndEvict(
      ::grpc::CallbackServerContext* /*context*/, const ::meringue::EvictionRequest* /*request*/, ::meringue::EvictionResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_RunGC : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_RunGC() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::meringue::GCRequest, ::meringue::GCResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::meringue::GCRequest* request, ::meringue::GCResponse* response) { return this->RunGC(context, request, response); }));}
    void SetMessageAllocatorFor_RunGC(
        ::grpc::MessageAllocator< ::meringue::GCRequest, ::meringue::GCResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::meringue::GCRequest, ::meringue::GCResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_RunGC() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunGC(::grpc::ServerContext* /*context*/, const ::meringue::GCRequest* /*request*/, ::meringue::GCResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RunGC(
      ::grpc::CallbackServerContext* /*context*/, const ::meringue::GCRequest* /*request*/, ::meringue::GCResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SortAndWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SortAndWrite() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::meringue::SortAndWriteRequest, ::meringue::SortAndWriteResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::meringue::SortAndWriteRequest* request, ::meringue::SortAndWriteResponse* response) { return this->SortAndWrite(context, request, response); }));}
    void SetMessageAllocatorFor_SortAndWrite(
        ::grpc::MessageAllocator< ::meringue::SortAndWriteRequest, ::meringue::SortAndWriteResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::meringue::SortAndWriteRequest, ::meringue::SortAndWriteResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SortAndWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SortAndWrite(::grpc::ServerContext* /*context*/, const ::meringue::SortAndWriteRequest* /*request*/, ::meringue::SortAndWriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SortAndWrite(
      ::grpc::CallbackServerContext* /*context*/, const ::meringue::SortAndWriteRequest* /*request*/, ::meringue::SortAndWriteResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_Initialize<WithCallbackMethod_PutSingleMD<WithCallbackMethod_GetSingleMD<WithCallbackMethod_DeleteSingleMD<WithCallbackMethod_UpdateCache<WithCallbackMethod_UpdateSizeAndEvict<WithCallbackMethod_RunGC<WithCallbackMethod_SortAndWrite<Service > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Initialize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Initialize() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Initialize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Initialize(::grpc::ServerContext* /*context*/, const ::meringue::InitializeRequest* /*request*/, ::meringue::InitializeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PutSingleMD : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PutSingleMD() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_PutSingleMD() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PutSingleMD(::grpc::ServerContext* /*context*/, const ::meringue::PutSingleMDRequest* /*request*/, ::meringue::PutSingleMDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetSingleMD : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetSingleMD() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_GetSingleMD() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSingleMD(::grpc::ServerContext* /*context*/, const ::meringue::GetSingleMDRequest* /*request*/, ::meringue::GetSingleMDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteSingleMD : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteSingleMD() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_DeleteSingleMD() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteSingleMD(::grpc::ServerContext* /*context*/, const ::meringue::DeleteSingleMDRequest* /*request*/, ::meringue::DeleteSingleMDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateCache : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UpdateCache() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_UpdateCache() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateCache(::grpc::ServerContext* /*context*/, const ::meringue::UpdateCacheRequest* /*request*/, ::meringue::UpdateCacheResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateSizeAndEvict : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UpdateSizeAndEvict() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_UpdateSizeAndEvict() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateSizeAndEvict(::grpc::ServerContext* /*context*/, const ::meringue::EvictionRequest* /*request*/, ::meringue::EvictionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RunGC : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RunGC() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_RunGC() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunGC(::grpc::ServerContext* /*context*/, const ::meringue::GCRequest* /*request*/, ::meringue::GCResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SortAndWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SortAndWrite() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_SortAndWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SortAndWrite(::grpc::ServerContext* /*context*/, const ::meringue::SortAndWriteRequest* /*request*/, ::meringue::SortAndWriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Initialize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Initialize() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Initialize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Initialize(::grpc::ServerContext* /*context*/, const ::meringue::InitializeRequest* /*request*/, ::meringue::InitializeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestInitialize(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PutSingleMD : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PutSingleMD() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_PutSingleMD() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PutSingleMD(::grpc::ServerContext* /*context*/, const ::meringue::PutSingleMDRequest* /*request*/, ::meringue::PutSingleMDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPutSingleMD(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetSingleMD : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetSingleMD() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_GetSingleMD() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSingleMD(::grpc::ServerContext* /*context*/, const ::meringue::GetSingleMDRequest* /*request*/, ::meringue::GetSingleMDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSingleMD(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteSingleMD : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteSingleMD() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_DeleteSingleMD() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteSingleMD(::grpc::ServerContext* /*context*/, const ::meringue::DeleteSingleMDRequest* /*request*/, ::meringue::DeleteSingleMDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteSingleMD(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UpdateCache : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UpdateCache() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_UpdateCache() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateCache(::grpc::ServerContext* /*context*/, const ::meringue::UpdateCacheRequest* /*request*/, ::meringue::UpdateCacheResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateCache(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UpdateSizeAndEvict : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UpdateSizeAndEvict() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_UpdateSizeAndEvict() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateSizeAndEvict(::grpc::ServerContext* /*context*/, const ::meringue::EvictionRequest* /*request*/, ::meringue::EvictionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateSizeAndEvict(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RunGC : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RunGC() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_RunGC() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunGC(::grpc::ServerContext* /*context*/, const ::meringue::GCRequest* /*request*/, ::meringue::GCResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRunGC(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SortAndWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SortAndWrite() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_SortAndWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SortAndWrite(::grpc::ServerContext* /*context*/, const ::meringue::SortAndWriteRequest* /*request*/, ::meringue::SortAndWriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSortAndWrite(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Initialize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Initialize() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Initialize(context, request, response); }));
    }
    ~WithRawCallbackMethod_Initialize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Initialize(::grpc::ServerContext* /*context*/, const ::meringue::InitializeRequest* /*request*/, ::meringue::InitializeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Initialize(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PutSingleMD : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PutSingleMD() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PutSingleMD(context, request, response); }));
    }
    ~WithRawCallbackMethod_PutSingleMD() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PutSingleMD(::grpc::ServerContext* /*context*/, const ::meringue::PutSingleMDRequest* /*request*/, ::meringue::PutSingleMDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PutSingleMD(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetSingleMD : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetSingleMD() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetSingleMD(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetSingleMD() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSingleMD(::grpc::ServerContext* /*context*/, const ::meringue::GetSingleMDRequest* /*request*/, ::meringue::GetSingleMDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSingleMD(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DeleteSingleMD : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DeleteSingleMD() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteSingleMD(context, request, response); }));
    }
    ~WithRawCallbackMethod_DeleteSingleMD() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteSingleMD(::grpc::ServerContext* /*context*/, const ::meringue::DeleteSingleMDRequest* /*request*/, ::meringue::DeleteSingleMDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DeleteSingleMD(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_UpdateCache : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_UpdateCache() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UpdateCache(context, request, response); }));
    }
    ~WithRawCallbackMethod_UpdateCache() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateCache(::grpc::ServerContext* /*context*/, const ::meringue::UpdateCacheRequest* /*request*/, ::meringue::UpdateCacheResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UpdateCache(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_UpdateSizeAndEvict : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_UpdateSizeAndEvict() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UpdateSizeAndEvict(context, request, response); }));
    }
    ~WithRawCallbackMethod_UpdateSizeAndEvict() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateSizeAndEvict(::grpc::ServerContext* /*context*/, const ::meringue::EvictionRequest* /*request*/, ::meringue::EvictionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UpdateSizeAndEvict(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_RunGC : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_RunGC() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RunGC(context, request, response); }));
    }
    ~WithRawCallbackMethod_RunGC() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunGC(::grpc::ServerContext* /*context*/, const ::meringue::GCRequest* /*request*/, ::meringue::GCResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RunGC(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SortAndWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SortAndWrite() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SortAndWrite(context, request, response); }));
    }
    ~WithRawCallbackMethod_SortAndWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SortAndWrite(::grpc::ServerContext* /*context*/, const ::meringue::SortAndWriteRequest* /*request*/, ::meringue::SortAndWriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SortAndWrite(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Initialize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Initialize() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::meringue::InitializeRequest, ::meringue::InitializeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::meringue::InitializeRequest, ::meringue::InitializeResponse>* streamer) {
                       return this->StreamedInitialize(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Initialize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Initialize(::grpc::ServerContext* /*context*/, const ::meringue::InitializeRequest* /*request*/, ::meringue::InitializeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedInitialize(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::meringue::InitializeRequest,::meringue::InitializeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PutSingleMD : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PutSingleMD() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::meringue::PutSingleMDRequest, ::meringue::PutSingleMDResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::meringue::PutSingleMDRequest, ::meringue::PutSingleMDResponse>* streamer) {
                       return this->StreamedPutSingleMD(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PutSingleMD() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PutSingleMD(::grpc::ServerContext* /*context*/, const ::meringue::PutSingleMDRequest* /*request*/, ::meringue::PutSingleMDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPutSingleMD(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::meringue::PutSingleMDRequest,::meringue::PutSingleMDResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetSingleMD : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetSingleMD() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::meringue::GetSingleMDRequest, ::meringue::GetSingleMDResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::meringue::GetSingleMDRequest, ::meringue::GetSingleMDResponse>* streamer) {
                       return this->StreamedGetSingleMD(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetSingleMD() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetSingleMD(::grpc::ServerContext* /*context*/, const ::meringue::GetSingleMDRequest* /*request*/, ::meringue::GetSingleMDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetSingleMD(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::meringue::GetSingleMDRequest,::meringue::GetSingleMDResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteSingleMD : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteSingleMD() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::meringue::DeleteSingleMDRequest, ::meringue::DeleteSingleMDResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::meringue::DeleteSingleMDRequest, ::meringue::DeleteSingleMDResponse>* streamer) {
                       return this->StreamedDeleteSingleMD(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteSingleMD() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteSingleMD(::grpc::ServerContext* /*context*/, const ::meringue::DeleteSingleMDRequest* /*request*/, ::meringue::DeleteSingleMDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteSingleMD(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::meringue::DeleteSingleMDRequest,::meringue::DeleteSingleMDResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateCache : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UpdateCache() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::meringue::UpdateCacheRequest, ::meringue::UpdateCacheResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::meringue::UpdateCacheRequest, ::meringue::UpdateCacheResponse>* streamer) {
                       return this->StreamedUpdateCache(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UpdateCache() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateCache(::grpc::ServerContext* /*context*/, const ::meringue::UpdateCacheRequest* /*request*/, ::meringue::UpdateCacheResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateCache(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::meringue::UpdateCacheRequest,::meringue::UpdateCacheResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateSizeAndEvict : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UpdateSizeAndEvict() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::meringue::EvictionRequest, ::meringue::EvictionResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::meringue::EvictionRequest, ::meringue::EvictionResponse>* streamer) {
                       return this->StreamedUpdateSizeAndEvict(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UpdateSizeAndEvict() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateSizeAndEvict(::grpc::ServerContext* /*context*/, const ::meringue::EvictionRequest* /*request*/, ::meringue::EvictionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateSizeAndEvict(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::meringue::EvictionRequest,::meringue::EvictionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RunGC : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RunGC() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::meringue::GCRequest, ::meringue::GCResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::meringue::GCRequest, ::meringue::GCResponse>* streamer) {
                       return this->StreamedRunGC(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RunGC() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RunGC(::grpc::ServerContext* /*context*/, const ::meringue::GCRequest* /*request*/, ::meringue::GCResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRunGC(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::meringue::GCRequest,::meringue::GCResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SortAndWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SortAndWrite() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::meringue::SortAndWriteRequest, ::meringue::SortAndWriteResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::meringue::SortAndWriteRequest, ::meringue::SortAndWriteResponse>* streamer) {
                       return this->StreamedSortAndWrite(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SortAndWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SortAndWrite(::grpc::ServerContext* /*context*/, const ::meringue::SortAndWriteRequest* /*request*/, ::meringue::SortAndWriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSortAndWrite(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::meringue::SortAndWriteRequest,::meringue::SortAndWriteResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Initialize<WithStreamedUnaryMethod_PutSingleMD<WithStreamedUnaryMethod_GetSingleMD<WithStreamedUnaryMethod_DeleteSingleMD<WithStreamedUnaryMethod_UpdateCache<WithStreamedUnaryMethod_UpdateSizeAndEvict<WithStreamedUnaryMethod_RunGC<WithStreamedUnaryMethod_SortAndWrite<Service > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_Initialize<WithStreamedUnaryMethod_PutSingleMD<WithStreamedUnaryMethod_GetSingleMD<WithStreamedUnaryMethod_DeleteSingleMD<WithStreamedUnaryMethod_UpdateCache<WithStreamedUnaryMethod_UpdateSizeAndEvict<WithStreamedUnaryMethod_RunGC<WithStreamedUnaryMethod_SortAndWrite<Service > > > > > > > > StreamedService;
};

}  // namespace meringue


#endif  // GRPC_meringue_2eproto__INCLUDED
